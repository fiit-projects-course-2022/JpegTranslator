class Decoder {
    field int width, height, dccoeff;
    field Array tables, quantizationTable;
    field List quantMapping;

    constructor Decoder new() {
        let tables = Array.new(17);
        let quantizationTable = Array.new(64);
        let quantMapping = List.new();
        return this;
    }

    method void Decode () {
        // Тут надо считывать байты из изображения с помощью вспомогательного класса Bytes
        var int byteIndex, header1, header2, chunkLen, chunkIndex;
        let byteIndex = 0;
        while(true){
            let header1 = Bytes.GetByte(byteIndex);
            let header2 = Bytes.GetByte(byteIndex+1);
            if (header1 = 255 & header2 = 216) { // start of file: marker = FFD8
                let chunkLen = 2;
            }
            else{
                if (header1 = 255 & header2 = 217) { // end of file: marker = FFD9
                    return;
                } else {
                    let chunkLen = 256 * Bytes.GetByte(byteIndex + 2) + Bytes.GetByte(byteIndex + 3) + 2;
                    let chunkIndex = byteIndex + 4;

                    if (header1 = 255){
                        if (header2 = 219) { do DefineQuantizationTables(chunkIndex, chunkLen - 4);} // quantization table: marker = FFDB
                        if (header2 = 192) { do BaseLineDCT(chunkIndex, chunkLen - 4); } // marker = FFC0
                        if (header2 = 196) { do DefineHuffmanTables(chunkIndex, chunkLen - 4); } // marker = FFC4
                        if (header2 = 218) { let chunkLen = StartOfScan(byteIndex, chunkLen); }
                        } 
                    }
                }
            let byteIndex = byteIndex + chunkLen;
            
            if (Bytes.GetByte(byteIndex) = -1) { return; }
            }
        return;
    }

    method IDCT BuildMatrix(Stream stream, int oldccoeff) {
        var IDCT inverseDCT;
        var HuffmanTable DC, AC;
        var int code, bits, l, coeff;

        let inverseDCT = IDCT.new();
        let DC = tables[0];
        let AC = tables[16];
        let code = DC.GetCode(stream);
        let bits = stream.GetBinN(code);

        let dccoeff = Extensions.DecodeNumber(code, bits) + oldccoeff;

        do inverseDCT.AddZigZag(0, dccoeff * quantizationTable[0]);
        let l = 1;
        while(l < 64) {
            let code = AC.GetCode(stream);

            if (code = 0) {
                return inverseDCT;
            }

            if (code > 15) {
                let l = l + (code / 16);
                let code = code & 15;
            }

            let bits = stream.GetBinN(code);

            if (l < 64) {
                let coeff = Extensions.DecodeNumber(code, bits);
                do inverseDCT.AddZigZag(l, coeff * quantizationTable[l]);
                let l = l + 1;
            }
        }
        return inverseDCT;
    }

    method int StartOfScan (int chunkIndex, int chunkLen) {
        var Stream stream;
        var IDCT matL;
        var int oldLumdcCoeff, y, x, yy, xx, blocksHeight, blocksWidth, color;

        let stream = Stream.new(chunkIndex + chunkLen);
        
        let blocksHeight = height / 8;
        let blocksWidth = width / 8;
        let y = 0;

        while(y < blocksHeight) {
            
            let x = 0;
            while(x < blocksWidth) {
                let matL = BuildMatrix(stream, oldLumdcCoeff);
                let oldLumdcCoeff = dccoeff;
                let yy = 0;
                while(yy < 8) {
                    let xx = 0;
                    while(xx < 8) {
                        let color = matL.GetFromBase(Extensions.XYtoLin(xx, yy));
                        if (color > 0) { do Screen.setColor(1); }
                        else { do Screen.setColor(0); }
                        do Screen.drawPixel(x * 8 + xx, y * 8 + yy);
                        let xx = xx + 1;
                    }
                    let yy = yy + 1;
                }
                do matL.dispose();
                let x = x + 1;
            }
            let y = y + 1;
        }
        return Bytes.GetLen() - chunkIndex - 2; 
    }

    method void DefineQuantizationTables (int chunkIndex, int chunkLen) {
        var int chunkPointer, header;
        let chunkPointer = chunkIndex;
        while(chunkPointer < chunkIndex + chunkLen) {
            let header = Bytes.GetByte(chunkPointer);
            if (header = 0) {
                let quantizationTable = Extensions.GetArray(chunkPointer + 1, chunkPointer + 1 + 64, 64);
                let chunkPointer = chunkPointer + 65;
            }
        }
        
        return;
    }

    method void BaseLineDCT(int chunkIndex, int chunkLen) {
        var int header, components, i, id, samp, QtbId;
        
        let header = Bytes.GetByte(chunkIndex);
        let height = Bytes.GetByte(chunkIndex + 1) * 256 + Bytes.GetByte(chunkIndex + 2);
        let width = Bytes.GetByte(chunkIndex + 3) * 256 + Bytes.GetByte(chunkIndex + 4);

        let i = 0;
        while(i < components) {
            let id = Bytes.GetByte(chunkIndex + 6 + (i * 3));
            let samp = Bytes.GetByte(chunkIndex + 7 + (i * 3));
            let QtbId = Bytes.GetByte(chunkIndex + 8 + (i * 3));
            let i = i + 1;
            do quantMapping.Add(QtbId);
        }
        return;
    }

    method void DefineHuffmanTables(int dataIndex, int dataLength) {
        var int off, header, sumLengths, i, j, staticOff, elementsIndex; 
        var Array lengths, elements, tempArray;
        var HuffmanTable hf;
        let lengths = Array.new(16);

        let off = dataIndex;

        while (off < (dataIndex + dataLength)) {
            let header = Bytes.GetByte(off);
            let off = off + 1;

            let lengths = Extensions.GetArray(off,off+16,16);
            let off = off + 16;

            let sumLengths = lengths[0]+lengths[1]+lengths[2]+lengths[3]+lengths[4]+lengths[5]+lengths[6]+lengths[7]+lengths[8]+lengths[9]+lengths[10]+lengths[11]+lengths[12]+lengths[13]+lengths[14]+lengths[15]; //смешная операция :D
            let elements = Array.new(sumLengths); 
            let i = 0;
            let elementsIndex = 0;
            while(i < 16) {
                let off = off + i;

                if(lengths[i] > 0) {
                    let tempArray = Extensions.GetArray(off, off+lengths[i], lengths[i]);                

                    let j = 0; //добавляем значения tempArray в конец elements
                    while (j < lengths[i]){ 
                        let elements[elementsIndex] = tempArray[j];
                        let j = j + 1;
                        let elementsIndex = elementsIndex + 1;
                    }
                    do tempArray.dispose();
                }
                let i = i + 1;
            }
            
            let hf = HuffmanTable.new();
            do hf.GetHuffmanBits(lengths, elements);
            let tables[header] = hf;
        }
        return;
    }
}